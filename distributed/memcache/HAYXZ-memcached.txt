memcached学习
------------------------------------------------------------------------------------------------
是什么
怎么用
为什么
------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------
Memcached是高性能的分布式内存缓存服务器。一般的使用目的是通过缓存数据库查询结果，减少数据库的访问次数，以提高动态Web 应用的速度、提高扩展性

Memcached 工作原理  
http://blog.csdn.net/bluejoe2000/article/details/44645659

1.Memcached处理的原子是每一个（key，value）对（以下简称kv对），key会通过一个hash算法转化成hash-key，便于查找、对比以及做到尽可能的散列。同时，memcached用的是一个二级散列，通过一张大hash表来维护。

2.Memcached有两个核心组件组成：服务端（ms）和客户端（mc），在一个memcached的查询中，mc先通过计算key的hash值来 确定kv对所处在的ms位置。当ms确定后，客户端就会发送一个查询请求给对应的ms，让它来查找确切的数据。因为这之间没有交互以及多播协议，所以 memcached交互带给网络的影响是最小化的。

3.举例说明：考虑以下这个场景，有三个mc分别是X，Y，Z，还有三个ms分别是A，B，C：

设置kv对
X想设置key=”foo”,value=”seattle”
X拿到ms列表，并对key做hash转化，根据hash值确定kv对所存的ms位置
B被选中了
X连接上B，B收到请求，把（key=”foo”,value=”seattle”）存了起来

获取kv对
Z想得到key=”foo”的value
Z用相同的hash算法算出hash值，并确定key=”foo”的值存在B上
Z连接上B，并从B那边得到value=”seattle”
其他任何从X，Y，Z的想得到key=”foo”的值的请求都会发向B

Memcached作为高速运行的分布式缓存服务器具有以下特点。
1.协议简单：memcached的服务器客户端通信并不使用复杂的MXL等格式，而是使用简单的基于文本的协议。 
2.基于libevent的事件处理：libevent是个程序库，他将Linux 的epoll、BSD类操作系统的kqueue等时间处理功能封装成统一的接口。memcached使用这个libevent库，因此能在Linux、BSD、Solaris等操作系统上发挥其高性能。 
3.内置内存存储方式：为了提高性能，memcached中保存的数据都存储在memcached内置的内存存储空间中。由于数据仅存在于内存中，因此重启memcached，重启操作系统会导致全部数据消失。另外，内容容量达到指定的值之后memcached回自动删除不适用的缓存。 
4.Memcached不互通信的分布式：memcached尽管是“分布式”缓存服务器，但服务器端并没有分布式功能。各个memcached不会互相通信以共享信息。他的分布式主要是通过客户端实现的。 

redis相对memcached
a.如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis。因为这两个特性Memcached都不具备。
b.即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis搜索也是明智的。
c.当然，最后还得说到你的具体应用需求。Redis相比Memcached来说，拥有更多的数据结构，并支持更丰富的数据操作。通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果你需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。
------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------
缓存式的Web应用程序架构
3种  
------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------
根据余数计算分散
Cache::Memcached的分布式方法简单来说，就是“根据服务器台数的余数进行分散”。 求得键的整数哈希值，再除以服务器台数，根据其余数来选择服务器

根据余数计算分散的缺点
余数计算的方法简单，数据的分散性也相当优秀，但也有其缺点。 那就是当添加或移除服务器时，缓存重组的代价相当巨大。 添加服务器后，余数就会产生巨变，这样就无法获取与保存时相同的服务器， 从而影响缓存的命中率。

mixi的Web应用程序运用中也有这个问题，导致无法添加memcached服务器。 但由于使用了新的分布式方法，现在可以轻而易举地添加memcached服务器了。 这种分布式方法称为 Consistent Hashing。
------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------
安装和使用
http://www.cnblogs.com/czh-liyu/archive/2010/04/27/1722084.html

常用命令
缓存管理命令
最后两个 memcached 命令用于监控和清理 memcached 实例。它们是 stats 和 flush_all 命令。
stats 
stats 命令的功能正如其名：转储所连接的 memcached 实例的当前统计数据。在下例中，执行 stats 命令显示了关于当前 memcached 实例的信息：
flush_all 
flush_all 是最后一个要介绍的命令。这个最简单的命令仅用于清理缓存中的所有名称/值对。如果您需要将缓存重置到干净的状态，则 flush_all 能提供很大的用处

缓存性能

在本文的最后，我将讨论如何使用高级 memcached 命令来确定缓存的性能。stats 命令用于调优缓存的使用。需要注意的两个最重要的统计数据是 et_hits 和 get_misses。这两个值分别指示找到名称/值对的次数（get_hits）和未找到名称/值对的次数（get_misses）。

结合这些值，我们可以确定缓存的利用率如何。初次启动缓存时，可以看到 get_misses 会自然地增加，但在经过一定的使用量之后，这些 get_misses 值应该会逐渐趋于平稳 — 这表示缓存主要用于常见的读取操作。如果您看到 get_misses 继续快速增加，而 get_hits 逐渐趋于平稳，则需要确定一下所缓存的内容是什么。您可能缓存了错误的内容。

确定缓存效率的另一种方法是查看缓存的命中率（hit ratio）。缓存命中率表示执行 get 的次数与错过 get 的次数的百分比

set
add
replace
get
delete
------------------------------------------------------------------------------------------------






















