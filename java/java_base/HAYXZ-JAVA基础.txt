
--------------------------------------------------------------------------------------------------------

java 基础
1.finally 方法在try 的return 之前执行 

2.final, finally, finalize的区别。
	final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
	内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……
	 
	finally是异常处理语句结构的一部分，表示总是执行。
	finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被用

3.Java中的异常处理机制的简单原理和应用。
	Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，
		Throwable下面又派生了两个子类：Error和Exception，
		Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。系统解决不了了
		Java 提供了两类主要的异常 :runtime exception 和 checked exception 。 
		Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，
		系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；
		普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。
	java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。

4.最常见到的5个runtime exception：
	NullPointerException、空指针
	ArrayIndexOutOfBoundsException、数组越界
	ClassCastException 类型强转
	IllegalArgumentException 参数非法
	WebServiceException
	BufferOverflowException 缓存溢出

	导致OutOfMemoryError异常的常见原因有以下几种：

		1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
		2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
		3.代码中存在死循环或循环产生过多重复的对象实体；
		4.使用的第三方软件中的BUG；
		5.启动参数内存值设定的过小；

	需要重点排查以下几点：
		1.检查代码中是否有死循环或递归调用。
		2.检查是否有大循环重复产生新对象实体。	
		3.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
		4.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。

5.string和stringBuffer
	1.String类是final类故不可以继承。 也不是八大基本类型 推荐用stringBuffer 
	String s="a"+"b"+"c"+"d"; 只创建了一个对象 
	javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果
	String s = "a" + "b" + "c" + "d";
	System.out.println(s == "abcd"); //true

	2.对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。
	而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。
	3.不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。
	当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即 StringBuffer。

6.java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
	第一种：
		new Thread(){}.start();这表示调用Thread子类对象的run方法，new Thread(){}表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：
		new Thread(){
		   public void run(){
		   }
		}.start();
 
	第二种：
		new Thread(new Runnable(){}).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable(){}表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：
		new Thread(new Runnable(){
					   public void run(){
					   }    
				}
		   ).start();

	从java5开始，还有如下一些线程池创建多线程的方式：
		ExecutorService pool = Executors.newFixedThreadPool(3)
		for(int i=0;i<10;i++)
		{
		 pool.execute(new Runable(){public void run(){}});
		}
		Executors.newCachedThreadPool().execute(new Runable(){public void run(){}});
		Executors.newSingleThreadExecutor().execute(new Runable(){public void run(){}});

	用synchronized关键字修饰同步方法

7.同步和异步有何异同，在什么情况下分别使用他们？举例说明。
	a.如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。<同步>
	b.当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。<异步>

8.多线程有几种实现方法?同步有几种实现方法?
	a.多线程有两种实现方法，分别是继承Thread类与实现Runnable接口
	b.同步的实现方面有两种，分别是synchronized,wait与notify
		wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
		sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。
		notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
		Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。
		end 

请编写代码模拟一个多线程的环境，要求如下：创建2个线程，一次对一个全局变量value进行操作，每隔2秒，线程A对value进行增加操作，线程B对value进行减少操作，当value值小于0时。线程B打印出“值小或等于0，停止减少”并进入等待状态，直到值大于0时，被通知后才继续工作，当A检测到value值大于100时，打印出“值超过100，停止增加”，并进入等待状态，直到值小于或等于100时。被通知后继续工作。 用JAVA实现


9.抽象类和接口的区别
	(1)接口可以被多重implements,抽象类只能被单一extends
	(2)接口只有定义,抽象类可以有定义和实现
	(3)接口的字段定义默认为:public static final, 抽象类字段默认是”protected”(本包可见)

10.Hashtable的原理,并说出HashMap与Hashtable的区别
	HashTable的原理:通过节点的关键码确定节点的存储位置,即给定节点的关键码k,通过一定的函数关系H(散列函数),得到函数值H(k),将此值解释为该节点的存储地址.
	HashMap 与Hashtable很相似,但HashMap 是非同步(unsynchronizded)和可以以null为关键码的.

11.类的static 代码段,可以看作是类首次加载(被虚拟机加载)执行的代码,
	而对于类的加载,首先要执行其基类的构造,再执行其本身的构造


15.什么是按值传递？什么是按引用传递？
	按值传递：就是将该值的副本传过去（基本数据类型+String类型的传递，就是按值传递）
	按引用传递：就是将值的内存地址传过去（除基本数据类型+String以外类型的传递，就是引用传递）

16.equals方法和”= =”的功能和区别
	功能：判断对象是否相等
	区别：
	equals方法比较的是对象的值
	= =:比较的是对象值的内存地址，对基本数据类型来说= =比较的是数值

17.接口的作用？为什么使用接口？
	多重继承
	封装、隔离
	功能,实现的分离
	多态
	便于后期维护
	接口是可插入性的保证。

18.描述出Java集合框架中集合的接口关系
	Collection—-Set和List
	Set—-HashSet和SortedSet
	List—-ArrayList和LinkedList
	Map—-HashMap、SortedMap和TreeMap

	1.
	List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。
	Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是不能集合里元素不允许重复的原因）。
	Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。

	2.
	List：保证以某种特定插入顺序来维护元素顺序，即保持插入的顺序，另外元素可以重复。
	ArrayList：是用数组实现的，读取速度快，插入与删除速度慢（因为插入与删除时要移动后面的元素），适合于随机访问。
	Vector：功能与ArrayList几乎相同，也是以数组实现，添加，删除，读取，设置都是基于线程同步的。
	LinkedList：双向链表来实现，删除与插入速度快，读取速度较慢，因为它读取时是从头向尾（如果节点在链的前半部分），或尾向头（如果节点在链的后半部分）查找元素。因此适合于元素的插入与删除操作。

	3.
	对Set的选择：
	HashSet的性能总比TreeSet好(特别是最常用的添加和查找元素操作)。
	TreeSet存在的唯一原因是，它可以维持元素的排序状态，所以只有当你需要一个排好序的Set时，才应该使用TreeSet。
	对于插入操作，LinkedHashSet比HashSet略微慢一点：这是由于维护链表所带来额外开销造成的。不过，因为有了链表，遍历LinkedHashSet会比HashSet更快。

	对Map的选择：
	Hashtable和HashMap的效率大致相同(通常HashMap更快一点，所以HashMap有意取代Hashtable)。
	TreeMap通常比HashMap慢，因为要维护排序。
	HashMap正是为快速查询而设计的。
	LinkedHashMap比HashMap慢一点，因为它维护散列数据结构的同时还要维护链表。

	4.Comparable接口和Comparator接口
	在“集合框架”中有两种比较接口：Comparable接口和Comparator接口。
	像String和Integer等Java内建类实现Comparable接口以提供一定排序方式，但这样只能实现该接口一次。
	对于那些没有实现Comparable接口的类、或者自定义的类，您可以通过 Comparator接口来定义您自己的比较方式。

	5.当以自己的对象做为HashMap、HashTable、LinkedHashMap、HashSet 、LinkedHashSet 的键时，一定要重写hashCode ()与equals ()方法，因为Object的hashCode()是返回内存地址，且equals()方法也是比较内存地址，所以当要在这些hash集合中查找时，如果是另外new出的新对象是查不到的，除非重写这两个方法。

	重写hashCode()与equals()这两个方法是针对哈希类，至于其它集合，如果要用public boolean contains(Object o)或containsValue(Object value)查找时，只需要实现equals()方法即可，他们都只使用对象的 equals方法进行比对，没有使用 hashCode方法。 

19.hashmap与hashtable异同

	hashmap
		线程不安全
		允许有null的键和值 在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null
		效率高一点、
		方法不是Synchronize的要提供外同步
		有containsvalue和containsKey方法
		HashMap 是Java1.2 引进的Map interface 的一个实现
		HashMap是Hashtable的轻量级实现

	hashtable
		线程安全
		不允许有null的键和值
		效率稍低、
		方法是是Synchronize的
		有contains方法方法
		Hashtable 继承于Dictionary 类
		Hashtable 比HashMap 要旧
	 
	Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。
	即是说，在多线程应用程序中，不用专门的操作就安全地可以使用Hashtable了；而对于HashMap，则需要额外的同步机制。
	但HashMap的同步问题可通过Collections的一个静态方法得到解决：
	Map Collections.synchronizedMap(Map m)
	这个方法返回一个同步的Map，这个Map封装了底层的HashMap的所有方法，使得底层的HashMap即使是在多线程的环境中也是安全的。

	可见Hashtable 继承自 Dictiionary 而 HashMap继承自AbstractMap 都实现了Map, Cloneable, Serializable等接口

20.arrayList和linkedListed 
	ArrayList：是用数组实现的，读取速度快，插入与删除速度慢（因为插入与删除时要移动后面的元素），适合于随机访问。
	LinkedList：双向链表来实现，删除与插入速度快，读取速度较慢，因为它读取时是从头向尾（如果节点在链的前半部分），或尾向头（如果节点在链的后半部分）查找元素。因此适合于元素的插入与删除操作。

21.反射和序列化

22.object对象的常见方法
	clone、toString、hashCode、wait、notify、getClass

23.并发与并行 
	并发的英文是 Concurrency，并行的英文是 Parallel，并发与并行是两个不同的概念。

	源自操作系统中的概念 存在一个宏观和微观 概念 
	所谓宏观：用户体验的角度 可能就是一样的 
	所谓微观：实际底层的实现 
	对应cpu的单核与多核 【fx -- ds】 应急面试场景 

	“并行”是指无论从微观还是宏观，二者都是一起执行的，就好像两个人各拿一把铁锨在挖坑，一小时后，每人一个大坑。 
	[注意看 郭盼经常喜欢给我挖坑 让我往里面跳]
	而“并发”在微观上不是同时执行的，【操作系统进程调度 时间片轮转】只是把时间分成若干段，使多个进程快速交替的执行，从宏观上来看，好像是这些进程都在执行，这就好像两个人用同一把铁锨，轮流挖坑，一小时后，两个人各挖一个小一点的坑，要想挖两个大一点得坑，一定会用两个小时。 
	从以上本质不难看出，“并发”执行，在多个进程存在资源冲突时，并没有从根本提高执行效率。

	一个处理器处理多个不同的任务和多个处理器处理多个不同的任务的区别 
	前者是逻辑的同时发生（给人宏观上的效果） 或者是物理上真正的同时发生 
----------------------------------------------------------------------------------------------
TX电话面试：
自我介绍
项目经验
项目中技术难点和难题
事务处理 
交易量 
基本的数据结构 hashmap 和hashtable 
排序算法 冒泡排序

李 

BD
------------------------------------------------------------------------------------------------
Access to National Scholarships
Won the National Motivational Scholarships
Won the School Principal Scholarship
Won the School First-class Scholarship
Won the school "Miyoshi Students" title
Won the School pacesetter "Miyoshi Students"
Was named "Outstanding Student Cadres"

vice President of Speech and eloquence association,  wuhan university of engineering

Wu Hancheng technology co., LTD Android development training


和优秀的人共事很简单，告诉他要做什么事，要什么效果，他就会想办法搞定，不需讲究条件。因为经过无数次经验的积累，他本人就成了成事最大的“条件”，缺了他，这事就搞不定。所以，越是出色的人，越善于在缺乏条件的状态下把事做好；越是平庸的人，越对做事的条件挑三拣四。--乔布斯

------------------------------------------------------------------------------------------------



------------------------------------------------------------------------------------------------
【多线程】
1.如果做 java web 方面开发的话几乎用不到多线程！因为有多线程的地方 servlet 容器或者其他开发框架都已经实现掉了！
	 一般在网络应用程序中使用多线程的地方非常多！

	以多线程来提高效率的场景一般在 CPU 计算型，而不是在 IO 读写型。CPU 可以会有多个核心并行处理计算，但是磁盘 IO 就没这功能了，磁头只有一个，根本不可能靠多线程提高效率！
	 一般来说，磁盘 IO 的并发能力为 0，也就是说无法支持并发！网络 IO 的话由于带宽的限制的，使用多线程处理最多也只能达到带宽的极值。
	 对于磁盘 IO 来说，多线程可以用于一个线程专门用于读写文件，其他的线程用于对读取数据进行处理，这样才有可能更好地利用 CPU 资源。

	还有一种极为普遍的使用多线程的场景是UI编程,一般UI界面绘制于主线程,为了不阻塞主线程让用户体验更流畅,需要创建单独的线程处理耗时操作,处理完了再更新主界面,典型的案例就是android应用开发 

2.常见面试题
第一题：线程的基本概念、线程的基本状态及状态之间的关系？
	线程，有时称为轻量级进程，是CPU使用的基本单元；它由线程ID、程序计数器、寄存器集合和堆栈组成。它与属于同一进程的其他线程共享其代码段、数据段和其他操作系统资源（如打开文件和信号）。

	线程有四种状态：新生状态、可运行状态、被阻塞状态、死亡状态。状态之间的转换如下图所示：

第二题：线程与进程的区别？
	1、 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。
	2、一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个进程，进程的执行过程不是一条线（线程）的，而是多条线（线程）共同完成的
	3、系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源。那就是说，出了CPU之外（线程在运行的时候要占用CPU资源），计算机内部的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。
	4、 与进程的控制表PCB相似，线程也有自己的控制表TCB，但是TCB中所保存的线程状态比PCB表中少多了。
	5、 进程是系统所有资源分配时候的一个基本单位，拥有一个完整的虚拟空间地址，并不依赖线程而独立存在。

第三题：多线程有几种实现方法，都是什么？
	1. 继承 Thread 类
	2. 实现 Runnable 接口再 new Thread(YourRunnableOjbect) 

第四题：多线程同步和互斥有几种实现方法，都是什么？
	用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。

第五题：多线程同步和互斥有何异同，在什么情况下分别使用他们？举例说明。
	线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。
	线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步（下文统称为同步）。

3.经典面试题
问题一：进程和线程的区别
	解答：一个进程对应一个程序的执行，而一个线程则是进程执行过程中的一个单独的执行序列，一个进程可以包含多个线程。线程有时候也被称为轻量级进程.

	一个Java虚拟机的实例运行在一个单独的进程中，不同的线程共享Java虚拟机进程所属的堆内存。这也是为什么不同的线程可以访问同一个对象。线程彼此共享堆内存并保有他们自己独自的栈空间。这也是为什么当一个线程调用一个方法时，他的局部变量可以保证线程安全。但堆内存并不是线程安全的，必须通过显示的声明同步来确保线程安全。

问题二:列举几种不同的创建线程的方法.
	解答:可以通过如下几种方式：
	•  继承Thread 类
	•  实现Runnable 接口
	•  使用Executor framework (这会创建一个线程池)

	通过线程池来创建更有效率。
	 相关链接: learn why and how to create pool of  threads using the executor framework

问题三：推荐通过哪种方式创建线程，为什么?
	解答：最好使用Runnable接口，这样你的类就不必继承Thread类.
	不然当你需要多重继承的时候，你将一筹莫展（我们都知道Java中的类只能继承自一个类，但可以同时实现多个接口）。
	在上面的例子中，因为我们要继承Base类，所以实现Runnable接口成了显而易见的选择。
	同时你也要注意到在不同的例子中，线程是如何启动的。
	按照面向对象的方法论，你应该只在希望改变父类的行为的时候才去继承他。
	通过实现Runnable接口来代替继承Thread类可以告诉使用者Counter是Base类型的一个对象，并会作为线程执行。

问题四：简要的说明一下高级线程状态.
	解答：下图说明了线程的各种状态.
	•可执行(Runnable)：当调用start()方法后，一个线程变为可执行状态，但是并不意味着他会立刻开始真正地执行。而是被放入线程池，由线程调度器根据线程优先级决定何时挂起执行。

	执行中(Running)：处理器已经在执行线程的代码。他会一直运行直到被阻断，或者通过静态方法Thread.yield()自行放弃执行的机会，考虑到场景切换所带来的开销，yield()方法不应该被经常调用。
	• 等待中(Waiting)：线程由于等待I/O等外部进程的处理结果而处于被阻断的状态，调用currObject.wait( )方法会使得当前线程进入等待状态，直到其它线程调用currObject.notify() 或者currObject.notifyAll() 。
	• 睡眠中(Sleeping)：重载方法Thread.sleep(milliseconds)，Thread.sleep(milliseconds， nanoseconds)可以迫使Java线程进入睡眠状态（挂起）。
	• 由于I/O阻塞（Blocked on I/O）：当I/O条件发生变化时（例如读取了几个字节的数据）会迁移到可执行状态。
	• 由于同步阻塞中（Blocked on synchronization）: 当获取锁之后会进入执行中状态。

	Thread.State  枚举类型包含了Java虚拟机支持的全部的线程状态类型，下面几点Java的线程宗旨确保了这些线程状态成为可能。
	• 对象可以被任何线程共享和修改。
	• 线程调度器的抢占性特性，使得线程可以随时在/不在多核处理之间切换处理器内核，这意味着方法可以在执行的过程中切换状态。否则方法中的死循环将永远阻塞CPU，并且使得不同线程的其他方法始终得不到执行。
	• 为了防止线程安全问题，那些脆弱的方法或者代码块可以被锁定。这使得线程可以处于被锁定或者加锁请求处理中两种状态。
	• 线程在处理I/O资源（如Sockets，文件句柄，数据库连接等）时会进入等待状态，
	• 处于I/O读写中的线程不能被切换，因此他们或者以成功/失败的结果正常完成处理，或者其它线程关闭了相应的资源，迫使他进入死亡或者完成的状态。这也是为什么一个合理的超时时间可以避免线程由于I/O处理而被永远阻塞，从而导致严重的性能问题。
	• 线程可以进入睡眠状态，以使得其他处于等待状态的线程有机会执行。

问题五：yield和sleeping有何区别，sleep()和wait()有何区别？
	解答：当一个任务调用了yield()方法，它将从执行中状态转变为可执行。而当一个任务调用了sleep()，则将从执行中状态转变为等待中/睡眠中状态。
	 方法wait(1000)使得当前线程睡眠1秒钟，但调用notify() 或者notifyAll()会随时唤醒线程。而sleep(1000)则会导致当前线程休眠1秒钟。

问题六：为什么为了线程安全而锁定一个方法或者一个代码块称为“同步”而不是“锁定”或者“被锁定”
	解答：当某个方法或者代码块被声明为”synchronized”后，保存数据的内存空间（例如堆内存）将保持被同步状态。
	 这意味着：当一个线程获取锁并且执行到已被声明为synchronized的方法或者代码块时，该线程首先从主堆内存空间中读取该锁定对象的所有变化，以确保其在开始执行之前拥有最新的信息。在synchronized部分执行完毕，线程准备释放锁的时候，所有针对被锁定对象的修改都将为写入主堆内存中。这样其他线程在请求锁的时候就可以获取最新的信息。

问题七：线程如何进行的同步处理？你可以列举出那些同步级别？同步方法和代码块如何区别？
	解答：在Java语言中，每个对象都有一个锁，一个线程可以通过关键字synchronized来申请获取某个对象的锁.
	关键字synchronized可以被用于方法（粗粒度锁，对性能影响较大）或代码块（细粒度锁）级别。
	锁定方法往往不是一个很好的选择，取而代之的我们应该只锁定那些访问共享资源的代码块.
	因为每一个对象都有一个锁，所以可以通过创建虚拟对象来实现代码块级别的同步，方法块级别的锁比锁定整个方法更有效。

	Java虚拟机灵活的使用锁和监视器，一个监视器总体来说就是一个守卫者，他负责确保只有一个线程会在同一时间执行被同步的代码。
	每个监视器对应一个对象的引用，在线程执行代码块的第一条指令之前，他必须持有该引用对象的锁，否则他将无法执行这段代码。
	一旦他获得锁，该线程就可以进入这段受到保护的代码。
	当线程不论以何种方式退出代码块时，他都将释放关联对象的锁。对于静态方法，需要请求类级别的锁。

===========================================================================================================
【HAYXZ】
1.
java：String使用equals和==比较的区别 
http://www.cnblogs.com/tinyphp/p/3768214.html

字符串池 除非new 会生成新的字符串 其他多是引用 


2.Collections,collection的区别
	Collection是个java.util下的接口，它是各种集合结构的父接口。
	Collections是个java.util下的普通类，它包含有各种有关集合操作的静态方法。
	Collections是针对集合类的一个帮助类，它提供一系列的静态方法实现对各种集合的搜索，排序，线程安全化等操作


3.反射和序列化


4.JVM 加载class 文件的原理机制
	ClassLoader
	
5.String StringBuffer StringBuilder
	String 字符串常量
	StringBuffer 字符串变量（线程安全）
	StringBuilder 字符串变量（非线程安全）

	String 是不可变的，StringBuffer/StringBuilder 是可变的；
	StringBuffer是线程安全的，StringBuilder是非线程安全的。 
	因而在大部分情况下字符串的拼接速度为：StringBuilder>StringBuffer>String 
	
	解释如下： 
	因为String是不可变的（通过ide的debugger可以发现其属性大都为final类型），
	因此每次对其操作改变其变量值，其实是生成一个新的对象，然后将变量引用指向新对象；因此速度慢。 

	StringBuffer则不同，对其操作即直接操作对象指向的引用，无需产生新对象，速度很快；
	它是线程安全的，在维护多线程的同步等也会消耗一点性能。 

	StringBuilder是jdk5之后新增的，其用法与StringBuffer完全一致，但它是线程不安全的，
	在单线程中最佳，因为其不需要维护线程的安全，因此是最快的。 

6. Concurrent包下线程安全的容器
	

	
	






