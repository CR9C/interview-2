<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/302292 (zh-CN); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="709"/>

<div>
<span><div style="-evernote-webclip:true"><br/></div><div style="font-size: 16px"><div style="font-family:Verdana, Arial, Helvetica, sans-serif;color:rgb(0, 0, 0);font-size:9pt;background:url(&quot;/Skins/coffee/images/bg_body.gif&quot;) 0% 0%;"><div style="text-align:left;"><div style="text-align:left;overflow-x:hidden;background:transparent;"><div style="background:url(&quot;/Skins/coffee/images/bg_left.gif&quot;) 0% 0% repeat-x rgb(254, 254, 242);"><div style="text-overflow:ellipsis;overflow:hidden;word-break:break-all;"><div style="border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:1005.58px;height:6902px;"><h1 style="font-size:14px;margin:0px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);width:1005.58px;border:0px none rgb(0, 0, 0);padding:0px;clear:both;padding-left:5px;float:left;font-weight:bold;"><a href="http://www.cnblogs.com/ITtangtang/p/3948786.html" style="margin:0px;padding:0px;text-decoration:none;color:rgb(7, 93, 179);border:0px none rgb(7, 93, 179);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;">Java集合---ConcurrentHashMap原理分析</a></h1><div style="border:0px none rgb(0, 0, 0);margin:0px;width:998.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);padding:5px 2px 5px 5px;margin-top:5px;font-size:13px;color:rgb(0, 0, 0);height:6866px;"><div style="margin:0px;padding:0px;margin-bottom:20px;word-break:break-word;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:6573px;"><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:57px;"> 集合是编程中最常用的数据结构。而谈到并发，几乎总是离不开集合这类高级<span style="x-evernote:highlighted;background-color:#F6EE96;">数据结构的支持。比如两个线程需要同时访问一个中间临界区（Queue），比如常会用缓存作为外部文件的副本（HashMap）。这篇文章主</span>要分析jdk1.5的3种并发集合类型（concurrent，copyonright，queue）中的ConcurrentHashMap，让我们从原理上细致的了解它们，能够让我们在深度项目开发中获益非浅。</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:114px;">    通过分析Hashtable就知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> 一、结构解析</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">   ConcurrentHashMap和Hashtable主要区别就是围绕着锁的粒度以及如何锁,可以简单理解成把一个大的HashTable分解成多个，形成了锁分离。如图:</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:304px;"><img src="ConcurrentHashMap原理分析_files/011042300165927.png" type="image/png" height="304" style="margin: 0px; padding: 0px; border: 0px none rgb(0, 0, 0); max-width: 900px; background-color: rgba(0, 0, 0, 0); background-image: none; box-shadow: none; width: 288px; height: auto;" width="288"/></p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">而Hashtable的实现方式是---锁整个hash表</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">二、应用场景</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">当有一个大数组时需要在多个线程共享时就可以考虑是否把它给分层多个节点了，避免大锁。并可以考虑通过hash算法进行一些模块定位。</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:38px;">其实不止用于线程，当设计数据表的事务时（事务某种意义上也是同步机制的体现），可以把一个表看成一个需要同步的数组，如果操作的表数据太多时就可以考虑事务分离了（这也是为什么要避免大表的出现），比如把数据进行字段拆分，水平分表等.</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">三、源码解读</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> ConcurrentHashMap中主要实体类就是三个：ConcurrentHashMap（整个Hash表）,Segment（桶），HashEntry（节点），对应上面的图可以看出之间的关系</p><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:72px;"><pre style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;word-wrap:break-word;white-space:pre-wrap;font-family:&apos;Courier New&apos;;height:72px;">
/** 
* The segments, each of which is a specialized hash table 
*/  
final Segment&lt;K,V&gt;[] segments; 
</pre></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:57px;">不变(Immutable)和易变(Volatile)<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:108px;"><pre style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;word-wrap:break-word;white-space:pre-wrap;font-family:&apos;Courier New&apos;;height:108px;">
1. static final class HashEntry&lt;K,V&gt; {  
2.     final K key;  
3.     final int hash;  
4.     volatile V value;  
5.     final HashEntry&lt;K,V&gt; next;  
6. }  
</pre></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:133px;">可以看到除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next 引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。这在讲解删除操作时还会详述。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
其它<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
为了加快定位段以及段中hash槽的速度，每个段hash槽的的个数都是2^n，这使得通过位运算就可以定位段和段中hash槽的位置。当并发级别为默认值16时，也就是段的个数，hash值的高4位决定分配在哪个段中。但是我们也不要忘记《算法导论》给我们的教训：hash槽的的个数不应该是 2^n，这可能导致hash槽分配不均，这需要对hash值重新再hash一次。（这段似乎有点多余了 ）</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">这是定位段的方法：</p><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:54px;"><pre style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;word-wrap:break-word;white-space:pre-wrap;font-family:&apos;Courier New&apos;;height:54px;">
1. final Segment&lt;K,V&gt; segmentFor(int hash) {  
2.     return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];  
3. } 
</pre></div><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:76px;">数据结构
<div>关于Hash表的基础数据结构，这里不想做过多的探讨。Hash表的一个很重要方面就是如何解决hash冲突，ConcurrentHashMap 和HashMap使用相同的方式，都是将hash值相同的节点放在一个hash链中。与HashMap不同的是，ConcurrentHashMap使用多个子Hash表，也就是段(Segment)。下面是ConcurrentHashMap的数据成员：</div></div><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div> </div></div><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:374px;"><div style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;font-family:&apos;Courier New&apos;;height:324px;">1. public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; <br/>
2.         implements ConcurrentMap&lt;K, V&gt;, Serializable { <br/>
3.     /** <br/>
4.      * Mask value for indexing into segments. The upper bits of a <br/>
5.      * key's hash code are used to choose the segment. <br/>
6.      */ <br/>
7.     final int segmentMask; <br/>
8.   <br/>
9.     /** <br/>
10.      * Shift value for indexing within segments. <br/>
11.      */ <br/>
12.     final int segmentShift; <br/>
13.   <br/>
14.     /** <br/>
15.      * The segments, each of which is a specialized hash table <br/>
16.      */ 
<div>17.     final Segment&lt;K,V&gt;[] segments; </div><div>18. } </div></div><div style="margin:0px;padding:0px;margin-top:5px;background-color:rgb(245, 245, 245);border:0px none rgb(0, 0, 0);background-image:none;box-shadow:none;width:986.578px;height:20px;"><div><br/></div></div></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:38px;">所有的成员都是final的，其中segmentMask和segmentShift主要是为了定位段，参见上面的segmentFor方法。
<div>每个Segment相当于一个子Hash表，它的数据成员如下：</div></div><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div> </div></div><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:716px;"><div style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;font-family:&apos;Courier New&apos;;height:666px;">1.     static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable { <br/>
2. private static final long serialVersionUID = 2249069246763182397L; <br/>
3.         /** <br/>
4.          * The number of elements in this segment's region. <br/>
5.          */ <br/>
6.         transient volatile int count; <br/>
7.   <br/>
8.         /** <br/>
9.          * Number of updates that alter the size of the table. This is <br/>
10.          * used during bulk-read methods to make sure they see a <br/>
11.          * consistent snapshot: If modCounts change during a traversal <br/>
12.          * of segments computing size or checking containsValue, then <br/>
13.          * we might have an inconsistent view of state so (usually) <br/>
14.          * must retry. <br/>
15.          */ <br/>
16.         transient int modCount; <br/>
17.   <br/>
18.         /** <br/>
19.          * The table is rehashed when its size exceeds this threshold. <br/>
20.          * (The value of this field is always &lt;tt&gt;(int)(capacity * <br/>
21.          * loadFactor)&lt;/tt&gt;.) <br/>
22.          */ <br/>
23.         transient int threshold; <br/>
24.   <br/>
25.         /** <br/>
26.          * The per-segment table. <br/>
27.          */ <br/>
28.         transient volatile HashEntry&lt;K,V&gt;[] table; <br/>
29.   <br/>
30.         /** <br/>
31.          * The load factor for the hash table.  Even though this value <br/>
32.          * is same for all segments, it is replicated to avoid needing <br/>
33.          * links to outer object. <br/>
34.          * @serial <br/>
35.          */ 
<div>36.         final float loadFactor; </div><div>37. } </div></div></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:95px;">count用来统计该段数据的个数，它是volatile(<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" style="margin:0px;padding:0px;text-decoration:underline;color:rgb(7, 93, 179);border:0px none rgb(7, 93, 179);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;" target="_blank">volatile 变量使用指南</a>)，它用来协调修改和读取操作，以保证读取操作能够读取到几乎最新的修改。协调方式是这样的，每次修改操作做了结构上的改变，如增加/删除节点(修改节点的值不算结构上的改变)，都要写count值，每次读取操作开始都要读取count的值。这利用了 Java 5中对volatile语义的增强，对同一个volatile变量的写和读存在happens-before关系。modCount统计段结构改变的次数，主要是为了检测对多个段进行遍历过程中某个段是否发生改变，在讲述跨段操作时会还会详述。threashold用来表示需要进行rehash的界限值。table数组存储段中节点，每个数组元素是个hash链，用HashEntry表示。table也是volatile，这使得能够读取到最新的 table值而不需要同步。loadFactor表示负载因子。</p><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div>先来看下删除操作remove(key)。</div></div><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div> </div></div><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:734px;"><div style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;font-family:&apos;Courier New&apos;;height:684px;">1. public V remove(Object key) { <br/>
2.  hash = hash(key.hashCode()); <br/>
3.     return segmentFor(hash).remove(key, hash, null); <br/>
4. } <br/>
整个操作是先定位到段，然后委托给段的remove操作。当多个删除操作并发进行时，只要它们所在的段不相同，它们就可以同时进行。下面是Segment的remove方法实现：<br/>
1. V remove(Object key, int hash, Object value) { <br/>
2.     lock(); <br/>
3.     try { <br/>
4.         int c = count - 1; <br/>
5.         HashEntry&lt;K,V&gt;[] tab = table; <br/>
6.         int index = hash &amp; (tab.length - 1); <br/>
7.         HashEntry&lt;K,V&gt; first = tab[index]; <br/>
8.         HashEntry&lt;K,V&gt; e = first; <br/>
9.         while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) <br/>
10.             e = e.next; <br/>
11.   <br/>
12.         V oldValue = null; <br/>
13.         if (e != null) { <br/>
14.             V v = e.value; <br/>
15.             if (value == null || value.equals(v)) { <br/>
16.                 oldValue = v; <br/>
17.                 // All entries following removed node can stay <br/>
18.                 // in list, but all preceding ones need to be <br/>
19.                 // cloned. <br/>
20.                 ++modCount; <br/>
21.                 HashEntry&lt;K,V&gt; newFirst = e.next; <br/>
22.                 *for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) <br/>
23.                     *newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash, <br/>
24.                                                   newFirst, p.value); <br/>
25.                 tab[index] = newFirst; <br/>
26.                 count = c; // write-volatile <br/>
27.             } <br/>
28.         } <br/>
29.         return oldValue; <br/>
30.     } finally { <br/>
31.         unlock(); 
<div>32.     } </div><div>33. } </div></div><div style="margin:0px;padding:0px;margin-top:5px;background-color:rgb(245, 245, 245);border:0px none rgb(0, 0, 0);background-image:none;box-shadow:none;width:986.578px;height:20px;"><div><br/></div></div></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:38px;">整个操作是在持有段锁的情况下执行的，空白行之前的行主要是定位到要删除的节点e。接下来，如果不存在这个节点就直接返回null，否则就要将e前面的结点复制一遍，尾结点指向e的下一个结点。e后面的结点不需要复制，它们可以重用。</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:57px;">中间那个for循环是做什么用的呢？（*号标记）从代码来看，就是将定位之后的所有entry克隆并拼回前面去，但有必要吗？每次删除一个元素就要将那之前的元素克隆一遍？这点其实是由entry的不变性来决定的，仔细观察entry定义，发现除了value，其他所有属性都是用final来修饰的，这意味着在第一次设置了next域之后便不能再改变它，取而代之的是将它之前的节点全都克隆一次。至于entry为什么要设置为不变性，这跟不变性的访问不需要同步从而节省时间有关</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">下面是个示意图</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">删除元素之前：</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:85px;"><img src="ConcurrentHashMap原理分析_files/011046327975389.png" type="image/png" height="85" style="margin: 0px; padding: 0px; border: 0px none rgb(0, 0, 0); max-width: 900px; background-color: rgba(0, 0, 0, 0); background-image: none; box-shadow: none; width: 497px; height: auto;" width="497"/></p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">删除元素3之后：</p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:172px;"><img src="ConcurrentHashMap原理分析_files/011046510631976.png" type="image/png" height="172" style="margin: 0px; padding: 0px; border: 0px none rgb(0, 0, 0); max-width: 900px; background-color: rgba(0, 0, 0, 0); background-image: none; box-shadow: none; width: 478px; height: auto;" width="478"/></p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:133px;">第二个图其实有点问题，复制的结点中应该是值为2的结点在前面，值为1的结点在后面，也就是刚好和原来结点顺序相反，还好这不影响我们的讨论。<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/><br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
整个remove实现并不复杂，但是需要注意如下几点。第一，当要删除的结点存在时，删除的最后一步操作要将count的值减一。这必须是最后一步操作，否则读取操作可能看不到之前对段所做的结构性修改。第二，remove执行的开始就将table赋给一个局部变量tab，这是因为table是 volatile变量，读写volatile变量的开销很大。编译器也不能对volatile变量的读写做任何优化，直接多次访问非volatile实例变量没有多大影响，编译器会做相应优化。<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/><br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/><div>接下来看put操作，同样地put操作也是委托给段的put方法。下面是段的put方法：</div></div><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div> </div></div><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:590px;"><div style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;font-family:&apos;Courier New&apos;;height:540px;">1. V put(K key, int hash, V value, boolean onlyIfAbsent) { <br/>
2.     lock(); <br/>
3.     try { <br/>
4.         int c = count; <br/>
5.         if (c++ &gt; threshold) // ensure capacity <br/>
6.             rehash(); <br/>
7.         HashEntry&lt;K,V&gt;[] tab = table; <br/>
8.         int index = hash &amp; (tab.length - 1); <br/>
9.         HashEntry&lt;K,V&gt; first = tab[index]; <br/>
10.         HashEntry&lt;K,V&gt; e = first; <br/>
11.         while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) <br/>
12.             e = e.next; <br/>
13.   <br/>
14.         V oldValue; <br/>
15.         if (e != null) { <br/>
16.             oldValue = e.value; <br/>
17.             if (!onlyIfAbsent) <br/>
18.                 e.value = value; <br/>
19.         } <br/>
20.         else { <br/>
21.             oldValue = null; <br/>
22.             ++modCount; <br/>
23.             tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value); <br/>
24.             count = c; // write-volatile <br/>
25.         } <br/>
26.         return oldValue; <br/>
27.     } finally { <br/>
28.         unlock(); 
<div>29.     } </div><div>30. } </div></div><div style="margin:0px;padding:0px;margin-top:5px;background-color:rgb(245, 245, 245);border:0px none rgb(0, 0, 0);background-image:none;box-shadow:none;width:986.578px;height:20px;"><div><br/></div></div></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:228px;">该方法也是在持有段锁(锁定整个segment)的情况下执行的，这当然是为了并发的安全，修改数据是不能并发进行的，必须得有个判断是否超限的语句以确保容量不足时能够rehash。接着是找是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。put方法调用了rehash方法，reash方法实现得也很精巧，主要利用了table的大小为2^n，这里就不介绍了。而比较难懂的是这句int index = hash &amp; (tab.length - 1)，原来segment里面才是真正的hashtable，即每个segment是一个传统意义上的hashtable,如上图，从两者的结构就可以看出区别，这里就是找出需要的entry在table的哪一个位置，之后得到的entry就是这个链的第一个节点，如果e!=null，说明找到了，这是就要替换节点的值（onlyIfAbsent == false），否则，我们需要new一个entry，它的后继是first，而让tab[index]指向它，什么意思呢？实际上就是将这个新entry插入到链头，剩下的就非常容易理解了<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/><br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
修改操作还有putAll和replace。putAll就是多次调用put方法，没什么好说的。replace甚至不用做结构上的更改，实现要比put和delete要简单得多，理解了put和delete，理解replace就不在话下了，这里也不介绍了。<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
获取操作
<div>首先看下get操作，同样ConcurrentHashMap的get操作是直接委托给Segment的get方法，直接看Segment的get方法：</div></div><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div> </div></div><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:320px;"><div style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;font-family:&apos;Courier New&apos;;height:270px;">1. V get(Object key, int hash) { <br/>
2.     if (count != 0) { // read-volatile 当前桶的数据个数是否为0 <br/>
3.         HashEntry&lt;K,V&gt; e = getFirst(hash);  得到头节点<br/>
4.         while (e != null) { <br/>
5.             if (e.hash == hash &amp;&amp; key.equals(e.key)) { <br/>
6.                 V v = e.value; <br/>
7.                 if (v != null) <br/>
8.                     return v; <br/>
9.                 return readValueUnderLock(e); // recheck <br/>
10.             } <br/>
11.             e = e.next; <br/>
12.         } <br/>
13.     } 
<div>14.     return null; </div><div>15. } </div></div><div style="margin:0px;padding:0px;margin-top:5px;background-color:rgb(245, 245, 245);border:0px none rgb(0, 0, 0);background-image:none;box-shadow:none;width:986.578px;height:20px;"><div><br/></div></div></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:228px;">get操作不需要锁。第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count 变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。接下来就是根据hash和key对hash链进行遍历找到要获取的结点，如果没有找到，直接访回null。对hash链进行遍历不需要加锁的原因在于链指针next是final的。但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在 table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。<br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/><br style="margin:0px;padding:0px;border:0px none rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;"/>
最后，如果找到了所求的结点，判断它的值如果非空就直接返回，否则在有锁的状态下再读一次。这似乎有些费解，理论上结点的值不可能为空，这是因为 put的时候就进行了判断，如果为空就要抛NullPointerException。空值的唯一源头就是HashEntry中的默认值，因为 HashEntry中的value不是final的，非同步读取有可能读取到空值。仔细看下put操作的语句：tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value)，在这条语句中，HashEntry构造函数中对value的赋值以及对tab[index]的赋值可能被重新排序，这就可能导致结点的值为空。这里当v为空时，可能是一个线程正在改变节点，而之前的get操作都未进行锁定，根据bernstein条件，读后写或写后读都会引起数据的不一致，所以这里要对这个e重新上锁再读一遍，以保证得到的是正确值。</p><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:194px;"><div style="margin:0px;padding:0px;margin-top:5px;background-color:rgb(245, 245, 245);border:0px none rgb(0, 0, 0);background-image:none;box-shadow:none;width:986.578px;height:20px;"><a style="margin:0px;padding:0px;text-decoration:underline;color:rgb(7, 93, 179);border:0px none rgb(7, 93, 179);background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;" target="_blank" title="复制代码"><img src="ConcurrentHashMap原理分析_files/copycode.gif" type="image/gif" alt="复制代码" height="20" style="margin: 0px; padding: 0px; border: 0px none rgb(7, 93, 179); background-color: rgb(245, 245, 245); max-width: 900px; background-image: none; box-shadow: none; width: 20px; height: auto;" width="20"/></a></div><pre style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;word-wrap:break-word;white-space:pre-wrap;font-family:&apos;Courier New&apos;;height:144px;">
1. V readValueUnderLock(HashEntry&lt;K,V&gt; e) {  
2.     lock();  
3.     try {  
4.         return e.value;  
5.     } finally {  
6.         unlock();  
7.     }  
8. }
</pre><div style="margin:0px;padding:0px;margin-top:5px;background-color:rgb(245, 245, 245);border:0px none rgb(0, 0, 0);background-image:none;box-shadow:none;width:986.578px;height:20px;"><a style="margin:0px;padding:0px;text-decoration:underline;color:rgb(7, 93, 179);border:0px none rgb(7, 93, 179);background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;" target="_blank" title="复制代码"><img src="ConcurrentHashMap原理分析_files/copycode [1].gif" type="image/gif" alt="复制代码" height="20" style="margin: 0px; padding: 0px; border: 0px none rgb(7, 93, 179); background-color: rgb(245, 245, 245); max-width: 900px; background-image: none; box-shadow: none; width: 20px; height: auto;" width="20"/></a></div></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;">另一个操作是containsKey，这个实现就要简单得多了，因为它不需要读取值：</p><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div> </div></div><div style="font-size:12px;margin:5px 0px;border:1px solid rgb(204, 204, 204);overflow:auto;color:rgb(0, 0, 0);width:986.578px;padding:5px;background-color:rgb(245, 245, 245);background-image:none;box-shadow:none;font-family:&apos;Courier New&apos;;height:248px;"><div style="font-size:12px;margin:0px;width:986.578px;box-shadow:none;background-image:none;background-color:rgba(0, 0, 0, 0);border:0px none rgb(0, 0, 0);padding:0px;margin-bottom:0px;margin-top:0px;font-family:&apos;Courier New&apos;;height:198px;">1. boolean containsKey(Object key, int hash) { <br/>
2.     if (count != 0) { // read-volatile <br/>
3.         HashEntry&lt;K,V&gt; e = getFirst(hash); <br/>
4.         while (e != null) { <br/>
5.             if (e.hash == hash &amp;&amp; key.equals(e.key)) <br/>
6.                 return true; <br/>
7.             e = e.next; <br/>
8.         } <br/>
9.     } 
<div>10.     return false; </div><div>11. } </div></div></div><p style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"> </p><div style="border:0px none rgb(0, 0, 0);margin:10px auto;color:rgb(0, 0, 0);font-size:13px;text-indent:0px;padding:0px;background-color:rgba(0, 0, 0, 0);background-image:none;box-shadow:none;width:998.578px;height:19px;"><div><br/></div></div></div></div></div></div></div></div></div></div></div><div style="-evernote-webclip:true"><br/></div></span>
</div></body></html> 